# state_transform

#前言
当初弄出这个，也是因为订单有各种状态，状态流转做的事情都是一样的，而且不同的状态到目标状态有很多种途径.
所以需要写很多service，各个操作都有对应的方法，这样显得不怎么集中

状态模式就是用来解决大量不同场景不同行为的模式

当然这个设计其实这不完全算是状态机模式，只是用状态机的思想，事件驱动状态流转。

个人总结的一些经验，希望能对你有所帮助，如果有什么好的意见或者建议，欢迎指点。
##状态机介绍

- 状态机可归纳为4个要素,即现态、事件、动作、次态。详解如下：

  #####①现态：是指当前对象所处的状态。
  #####②事件：也可称为"条件"。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。
  #####③动作：条件满足后执行的动作，动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到目标状态。
  #####④次态：条件满足后要迁往的目标状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，对象就转变成新的“现态”了。

- 状态机就是将驱动类，根据当前状态得到对应的执行者，执行者再根据指定事件，做对应动作，将当前状态改变为目标状态
     驱动类可以用同一个对象，也可以根据不同的事件操作使用不同的对象，例如订单审核没有其他个性化参数，就可以直接用公共的驱动者。
     再比如支付回调，将未支付改为待审核，就有支付时间这样个性化的参数，就可以用SaleOrderPayEventDriver驱动

##状态机实践
```java
//驱动者-->设置当前订单状态-->得到行动队长-->执行期望动作
//审核订单，状态流转到待发货。详细可参考OrderController.java 37行
saleOrderEventDriver.status(SaleOrderStatusEnum.WAITING_AUDIT.getCode()).handle(SaleOrderEventEnum.AUDIT_TO_DELIVER);

```

## 状态设计的一点建议
- 事件编码需要有间隙，便于插入子事件，状态枚举也是，便于插入子状态或者中间状态 

  